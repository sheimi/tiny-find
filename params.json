{"body":"TINY-FIND \r\n==============\r\n    Homework -- to fake a command -- find >_<!~~~\r\n\r\n## OVERVIEW\r\n    This is my homework of \"Linux Programming\". \r\n    This is the of \"Tiny Find\", my version of \"find\".\r\n\r\n### MAKE\r\n    make or make DEBUG=1 for debug version\r\n\r\n## SPECIFICATION\r\n    usage: tinyfind [-H | -L | -P] [-EXdsx] [-f path] path ... [expression]\r\n           tinyfind [-H | -L | -P] [-EXdsx] -f path [path ...] [expression]\r\n### OPTIONS\r\n    -H      Cause the file information and file type (see stat(2)) returned\r\n            for each symbolic link specified on the command line to be those\r\n            of the file referenced by the link, not the link itself.  If the\r\n            referenced file does not exist, the file information and type\r\n            will be for the link itself.  File information of all symbolic\r\n            links not on the command line is that of the link itself.\r\n\r\n    -L      Cause the file information and file type (see stat(2)) returned\r\n            for each symbolic link to be those of the file referenced by the\r\n            link, not the link itself.  If the referenced file does not\r\n            exist, the file information and type will be for the link itself.\r\n            This option is equivalent to the deprecated -follow primary.\r\n\r\n    -P      Cause the file information and file type (see stat(2)) returned\r\n            for each symbolic link to be those of the link itself.  This is\r\n            the default.\r\n\r\n\r\n\r\n### LOGIC EXPRESSIONS\r\n    exps can linked with logic expression and '(', ')' \r\n    -not\r\n    -and\r\n    -or\r\n    '(', ')' should be used after Escape character \\. exp '\\(' and '\\(' \r\n\r\n### ACTIONS\r\n    -exec [argv] \\;\r\n      if it is true, excute the cmd. \r\n    -ok [argv] \\;\r\n      if it is true, excute the cmd.(ask first) \r\n    -print\r\n      if it is true, printf it\r\n    -print0\r\n      if it is true, printf it without '\\n'\r\n\r\n\r\n### EXPRESSIONS\r\n    -name\r\n      True if the last component of the pathname being examined matches pattern.\r\n      Special shell pattern matching characters (``['', ``]'', ``*'', and ``?'')\r\n      may be used as part of pattern.  These characters may be matched \r\n      explicitly by escaping them with a backslash (``\\'').\r\n    -iname\r\n      Like -name, but the match is case insensitive\r\n    -user [username | user_id]\r\n      True if the file belongs to the user\r\n    -group [groupname | group_id]\r\n      True if the file belongs to the group\r\n    -perm [perm(exp 777)]\r\n      True if the file match such perm\r\n    -regex [reg]\r\n      True if the filename match the regex expression\r\n    -amin [n]\r\n      True if the file is accessed in n minutes \r\n    -atime [n]\r\n      True if the file is accessed in n days \r\n    -anewer [file2]\r\n      True if the file is accessed later than file2\r\n    -cmin [n]\r\n      True if the file is changed in n minutes \r\n    -ctime [n]\r\n      True if the file is changed in n days \r\n    -cnewer [file2]\r\n      True if the file is changed later than file2\r\n    -mmin [n]\r\n      True if the file is modified in n minutes \r\n    -mtime [n]\r\n      True if the file is modified in n days \r\n    -mnewer [file2]\r\n      True if the file is modified later than file2\r\n    -type [b|c|d|f|l|p]\r\n      b       block special\r\n      c       character special\r\n      d       directory\r\n      f       regular file\r\n      l       symbolic link\r\n      p       FIFO\r\n      s       socket\r\n    -size\r\n      True if the file's size, rounded up, in 512-byte blocks is n. \r\n      If n is followed by a c, then the primary is true if the file's \r\n      size is n bytes (characters).  Similarly if n is followed by a \r\n      scale indicator then the file's size is compared to n scaled as:\r\n\r\n        k       kilobytes (1024 bytes)\r\n        M       megabytes (1024 kilobytes)\r\n        G       gigabytes (1024 megabytes)\r\n        T       terabytes (1024 gigabytes)\r\n        P       petabytes (1024 terabytes)\r\n\r\n## DESIGN\r\n### SOURCE FILES\r\n    the src folder includes:\r\n      Makefile    the makefile of the tool\r\n      env.h       | global include, define, and struct\r\n\r\n      parser.h    | the parser of expressions from the bash.\r\n      parser.c    | it will translate the exp to postfix expression\r\n\r\n      filter.h    | build the filter tree and  \r\n      filter.c    | inplement all the filters\r\n\r\n      tinyfind.c  | the main file of tool and it use api to \r\n                  | traverse a file hierarchy   \r\n\r\n### FILTER DESIGN\r\n    a. Filter Tree And Filter\r\n       Filter tree is a binary tree with node has a two pointer, passed and failed.\r\n       If the filter fails, it will exicute the filter that failed pointer pointed.\r\n       Filter contains a pointer to a filter_cmd.\r\n         filter_cmd  | a function pointer which contains the test function to test   \r\n                     | whether a file can meets a expression\r\n       Filter contains a FilterType.\r\n         FilterType  | it is a enum and cantains the type information of a filter\r\n       Filter contains a void pointer, info.\r\n         info        | it contains some necessary information of a specific filter\r\n       each filter should implement at least two function:\r\n         init_xxx    | to init the a filter\r\n         xxx_filter  | it is filter_cmd, the test function.\r\n\r\n    b. Build the Filter Tree\r\n       There are three functions to build the tree\r\n         filter_and  | connect to filter tree with and operation\r\n         filter_or   | connect to filter tree with or operation\r\n         filter_not  | wrap a filter in a not filter adapter\r\n       There are a stack to compute logic operations.\r\n\r\n    c. RELEASE the Filter Tree\r\n       There is a list to track all the filters.\r\n       if a filter should release the information in filter, it should be add to\r\n       the _free_filter fuction. \r\n\r\n## FLEXIBLE\r\n### ADD A EXPRESSION\r\n    a. add the name of the  expression to FilterType in 'filter.h' and ALL_EXP\r\n       in 'parser.c'\r\n    b. impelment function init_xxx and xxx_filter in 'filter.c'\r\n    c. register the filter to the init_filter_tree function in 'filter.c' \r\n    that's all\r\n### ADD A ACTION\r\n    a. add the name of the action to ALL_OPTIONS in 'parser.c'\r\n    b. add flags in options\r\n    c. add some code of the action in set_post_exp in 'parser.c'\r\n    d. add the operation in function check in 'tinyfind.c'\r\n    that's all\r\n### ADD A OPTION\r\n    a. add the name of the option to ALL_OPTIONS in 'parser.c'\r\n    b. add flags in options\r\n    c. add some code of the option  in set_post_exp in 'parser.c'\r\n    d. add the operation in function find in 'tinyfind.c'\r\n    that's all\r\n\r\n## COMPARISON\r\n    It can have a tree of test functions 'predicate tree'\r\n    It uses 'fts' api to traverse a file hierarchy\r\n    pred.c    | it contains all the test functions\r\n    tree.c    | to connect all the test functions into a tree\r\n\r\n    In my version of 'find', filter tree plays a similar role as tree \r\n    and filter plays a similar role as predicate.\r\n\r\n    The offical 'find' also has a parser to parse the bash parameters, but it is\r\n    more powerful.\r\n\r\n\r\n\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","tagline":"homeword to fake a find command in linux","name":"Tiny-find","google":"UA-35791128-2"}